```
layout: post
title: 行为树设计在怪物移动中出现的问题
excerpt:  
```

在早期的行为树设计中, 动作节点无法监听事件,  而移动节点也并非像传统的 tick-driven 行为树那样, 每帧检查移动状态. 而是在获取到navmesh坐标点后, 起一个移动定时器, 定时器结束后会回调执行行为树的后续任务, 其移动中断是靠上层的条件节点来实现的. 

所以, 每个追逐移动节点都必须带一个距离判断条件节点. 否则无法被打断. 这个设计当然有很多弊端.

首先是配置繁琐, 即使行为树编辑器有复制粘贴功能, 也足以折磨策划半天.

其次, 当场景发生改变时, 怪物还沿着之前的路径走, 想要得到及时反馈就得新增相应的条件节点. 

而最终促使改变的导火索, 是怪物的移动避障: 当AI控制怪物移动到某一点时, 会从navmesh取到坐标并同步给客户端播放. 而怪物在移动过程中躲避其他对象的动态避障由客户端自行计算, 服务器无法感知. 于是就造成了客户端和服务器坐标对不上并闪现的问题. 

若将客户端使用的RVO算法直接搬到服务器, 又出现了新的问题. RVO算法需要持续计算, 若移动前仅计算一次避障, 仍无法避免移动过程中产生的新的碰撞.

结合以上的种种问题, 我们还是选择了使动作节点也可以监听事件, 但仅限于移动在内的几个动作节点.

具体实现为, 类似于UE中的移动节点, 每次监听到其他单位的移动事件后去检查距离和路径状态, 在必要的时候还会使用RVO来计算避障路径. 但是事件响应仅在节点内运行, 不会传播到行为树其他节点. 

此外还解决了怪物追逐动态目标的问题, 策划再也不需要额外配置一大堆条件节点了.


